#include "PickResult.h"
#include <trview.common/Colour.h>
#include "../Elements/ILevel.h"
#include "../Routing/IRoute.h"
#include "../Elements/SoundSource/ISoundSource.h"

namespace trview
{
    Colour pick_to_colour(const PickResult& pick)
    {
        switch (pick.type)
        {
        case PickResult::Type::Entity:
        case PickResult::Type::Waypoint:
            return Colour(0.0f, 1.0f, 0.0f);
        case PickResult::Type::Trigger:
            return Colour(1.0f, 0.0f, 1.0f);
        }
        return Colour(1.0f, 1.0f, 1.0f);
    }

    PickResult nearest_result(const PickResult& current, const PickResult& next)
    {
        if (next.hit && next.distance < current.distance)
        {
            return next;
        }
        return current;
    }

    std::string generate_pick_message(const PickResult& result, const ILevel& level)
    {
        std::stringstream stream;

        switch (result.type)
        {
            case PickResult::Type::Entity:
            {
                if (const auto item = result.item.lock())
                {
                    return std::format("Item {} - {}{}", item->number(), item->type(), is_virtual(*item) ? "\nVirtual item generated by trview" : "");
                }
                break;
            }
            case PickResult::Type::Trigger:
            {
                if (const auto trigger = result.trigger.lock())
                {
                    stream << to_string(trigger->type()) << " " << trigger->number();
                    for (const auto command : trigger->commands())
                    {
                        stream << "\n  " << command_type_name(command.type());
                        if (command_has_index(command.type()))
                        {
                            stream << " " << command.index();
                            if (command_is_item(command.type()))
                            {
                                const auto item = level.item(command.index()).lock();
                                stream << " - " << (item ? item->type() : "No Item");
                            }
                        }
                    }
                }
                break;
            }
            case PickResult::Type::Light:
            {
                if (const auto light = result.light.lock())
                {
                    stream << "Light " << light->number() << " - " << to_string(light->type());
                }
                break;
            }
            case PickResult::Type::Room:
            {
                if (const auto room = result.room.lock())
                {
                    stream << "Room " << room->number();
                }
                break;
            }
            case PickResult::Type::Waypoint:
            {
                if (auto waypoint = result.waypoint.lock())
                {
                    stream << "Waypoint " << result.waypoint_index;

                    if (waypoint->type() == IWaypoint::Type::Entity)
                    {
                        if (const auto item = level.item(waypoint->index()).lock())
                        {
                            stream << " - " << item->type();
                        }
                    }
                    else if (waypoint->type() == IWaypoint::Type::Trigger)
                    {
                        if (const auto trigger = level.trigger(waypoint->index()).lock())
                        {
                            stream << " - " << to_string(trigger->type()) << " " << waypoint->index();
                        }
                    }

                    const auto notes = waypoint->notes();
                    if (!notes.empty())
                    {
                        stream << "\n\n" << notes;
                    }
                }
                break;
            }
            case PickResult::Type::Compass:
            {
                stream << result.text;
                break;
            }
            case PickResult::Type::CameraSink:
            {
                if (const auto camera_sink = result.camera_sink.lock())
                {
                    stream << to_string(camera_sink->type()) << " " << camera_sink->number();
                }
                break;
            }
            case PickResult::Type::StaticMesh:
            {
                if (const auto static_mesh = result.static_mesh.lock())
                {
                    stream << to_string(static_mesh->type()) << " " << static_mesh->number();
                }
                break;
            }
            case PickResult::Type::Scriptable:
            {
                if (const auto scriptable = result.scriptable.lock())
                {
                    stream << scriptable->tooltip();
                }
                break;
            }
            case PickResult::Type::SoundSource:
            {
                if (const auto sound_source = result.sound_source.lock())
                {
                    stream << "Sound Source " << sound_source->number() << " - ";
                    const auto sample = sound_source->sample();
                    stream << (sample ? std::format("Sample {}", sample.value()) : "Missing Sample");
                }
                break;
            }
        }

        return stream.str();
    }
 }