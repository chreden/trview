#include "StaticsWindow.h"
#include "../RowCounter.h"
#include "../../trview_imgui.h"

namespace trview
{
    IStaticsWindow::~IStaticsWindow()
    {
    }

    StaticsWindow::StaticsWindow()
    {
        setup_filters();
    }

    void StaticsWindow::render()
    {
        if (!render_statics_window())
        {
            on_window_closed();
            return;
        }
    }

    bool StaticsWindow::render_statics_window()
    {
        bool stay_open = true;
        ImGui::PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(540, 500));
        if (ImGui::Begin(_id.c_str(), &stay_open))
        {
            render_statics_list();
            ImGui::SameLine();
            render_static_details();
            _force_sort = false;
        }
        ImGui::End();
        ImGui::PopStyleVar();
        return stay_open;
    }

    void StaticsWindow::render_statics_list()
    {
        calculate_column_widths();
        if (ImGui::BeginChild(Names::statics_list_panel.c_str(), ImVec2(0, 0), ImGuiChildFlags_AutoResizeX, ImGuiWindowFlags_NoScrollbar))
        {
            _filters.render();

            // TODO: 
            // ImGui::SameLine();
            // _track.render();

            // TODO:
            // ImGui::SameLine();
            // bool sync_item = _sync_item;
            // if (ImGui::Checkbox(Names::sync_item.c_str(), &sync_item))
            // {
            //     set_sync_item(sync_item);
            // }

            RowCounter counter{ "statics", _all_statics.size() };
            if (ImGui::BeginTable(Names::statics_list.c_str(), 4, ImGuiTableFlags_Sortable | ImGuiTableFlags_ScrollY, ImVec2(0, -counter.height())))
            {
                ImGui::TableSetupColumn("#", ImGuiTableColumnFlags_WidthFixed, _column_sizer.size(0));
                ImGui::TableSetupColumn("Room", ImGuiTableColumnFlags_WidthFixed, _column_sizer.size(1));
                ImGui::TableSetupColumn("ID", ImGuiTableColumnFlags_WidthFixed, _column_sizer.size(2));
                ImGui::TableSetupColumn("Type", ImGuiTableColumnFlags_WidthFixed, _column_sizer.size(3));
                // ImGui::TableSetupColumn("Hide", ImGuiTableColumnFlags_WidthFixed, _column_sizer.size(4));
                ImGui::TableSetupScrollFreeze(1, 1);
                ImGui::TableHeadersRow();

                imgui_sort_weak(_all_statics,
                    {
                        [](auto&& l, auto&& r) { return l.number() < r.number(); },
                        [](auto&& l, auto&& r) { return std::tuple(static_mesh_room(l), l.number()) < std::tuple(static_mesh_room(r), r.number()); },
                        [](auto&& l, auto&& r) { return l.id() < r.id(); },
                        [](auto&& l, auto&& r) { return l.type() < r.type(); },
                        // [](auto&& l, auto&& r) { return std::tuple(l.visible(), l.number()) < std::tuple(r.visible(), r.number()); }
                    }, _force_sort);

                for (const auto& stat : _all_statics)
                {
                    auto stat_ptr = stat.lock();
                    if (!stat_ptr || ( /* _track.enabled<Type::Room>() && item_ptr->room().lock() != _current_room.lock() || */ !_filters.match(*stat_ptr)))
                    {
                        continue;
                    }

                    counter.count();
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn();
                    // auto selected_item = _selected_item.lock();
                    // bool selected = selected_item && selected_item == item_ptr;
                    // 
                    ImGuiScroller scroller;
                    // if (selected && _scroll_to_item)
                    // {
                    //     scroller.scroll_to_item();
                    //     _scroll_to_item = false;
                    // }
                    // 
                    // const bool item_is_virtual = is_virtual(*item_ptr);

                    bool selected = false;
                    ImGui::SetNextItemAllowOverlap();
                    if (ImGui::Selectable(std::format("{0}##{0}", stat_ptr->number()).c_str(), &selected, ImGuiSelectableFlags_SpanAllColumns | static_cast<int>(ImGuiSelectableFlags_SelectOnNav)))
                    {
                        scroller.fix_scroll();

                        // set_local_selected_item(item);
                        // if (_sync_item)
                        // {
                        //     on_item_selected(item);
                        // }
                        _scroll_to_static = false;
                    }

                    // if (item_is_virtual && ImGui::IsItemHovered())
                    // {
                    //     ImGui::BeginTooltip();
                    //     ImGui::Text("Virtual item generated by trview");
                    //     ImGui::EndTooltip();
                    // }

                    ImGui::TableNextColumn();
                    ImGui::Text(std::to_string(static_mesh_room(*stat_ptr)).c_str());
                    ImGui::TableNextColumn();
                    ImGui::Text(std::to_string(stat_ptr->id()).c_str());
                    ImGui::TableNextColumn();
                    ImGui::Text(to_string(stat_ptr->type()).c_str());
                    //ImGui::TableNextColumn();
                    //ImGui::Text(std::to_string(item_ptr->type_id()).c_str());
                    //ImGui::TableNextColumn();
                    //ImGui::Text(item_ptr->type().c_str());
                    //ImGui::TableNextColumn();
                    // bool hidden = !item_ptr->visible();
                    // ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
                    // if (ImGui::Checkbox(std::format("##hide-{}", item_ptr->number()).c_str(), &hidden))
                    // {
                    //     on_item_visibility(item, !hidden);
                    // }
                    // ImGui::PopStyleVar();
                }
                ImGui::EndTable();
                counter.render();
            }
        }
        ImGui::EndChild();
    }

    void StaticsWindow::render_static_details()
    {

    }

    void StaticsWindow::set_number(int32_t number)
    {
        _id = std::format("Statics {}", number);
    }

    void StaticsWindow::update(float)
    {
    }

    void StaticsWindow::calculate_column_widths()
    {
        _column_sizer.reset();
        
        _column_sizer.measure("#__", 0);
        _column_sizer.measure("Room__", 1);
        _column_sizer.measure("ID__", 2);
        _column_sizer.measure("Type______", 3);
        // _column_sizer.measure("Hide____", 4);

        for (const auto& stat : _all_statics)
        {
            if (auto stat_ptr = stat.lock())
            {
                // const bool item_is_virtual = is_virtual(*item_ptr);
                _column_sizer.measure(std::format("{0}##{0}", stat_ptr->number()), 0);
                _column_sizer.measure(std::to_string(static_mesh_room(*stat_ptr)), 1);
                _column_sizer.measure(std::to_string(stat_ptr->id()), 2);
                _column_sizer.measure(to_string(stat_ptr->type()), 3);
                // _column_sizer.measure(std::to_string(item_ptr->type_id()), 2);
                // _column_sizer.measure(item_ptr->type(), 3);
            }
        }
    }

    void StaticsWindow::set_statics(const std::vector<std::weak_ptr<IStaticMesh>>& statics)
    {
        _all_statics = statics;
        setup_filters();
        _force_sort = true;
        calculate_column_widths();
    }

    void StaticsWindow::setup_filters()
    {
        _filters.clear_all_getters();

        std::set<std::string> available_types;
        for (const auto& stat : _all_statics)
        {
            if (auto stat_ptr = stat.lock())
            {
                available_types.insert(to_string(stat_ptr->type()));
            }
        }
        _filters.add_getter<std::string>("Type", { available_types.begin(), available_types.end() }, [](auto&& stat) { return to_string(stat.type()); });
        // _filters.add_multi_getter<std::string>("Category", { available_categories.begin(), available_categories.end() }, [](auto&& item)
        //     {
        //         std::vector<std::string> results;
        //         for (const auto& category : item.categories())
        //         {
        //             results.push_back(category);
        //         }
        //         return results;
        //     });
        _filters.add_getter<float>("#", [](auto&& stat) { return static_cast<float>(stat.number()); });
        // _filters.add_getter<float>("X", [](auto&& item) { return item.position().x * trlevel::Scale_X; });
        // _filters.add_getter<float>("Y", [](auto&& item) { return item.position().y * trlevel::Scale_Y; });
        // _filters.add_getter<float>("Z", [](auto&& item) { return item.position().z * trlevel::Scale_Z; });
        // _filters.add_getter<float>("Angle", [](auto&& item) { return static_cast<float>(bound_rotation(item.angle())); });
        // _filters.add_getter<float>("Angle Degrees", [](auto&& item) { return static_cast<float>(bound_rotation(item.angle()) / 182); });
        _filters.add_getter<float>("ID", [](auto&& stat) { return static_cast<float>(stat.id()); });
        _filters.add_getter<float>("Room", [](auto&& stat) { return static_cast<float>(static_mesh_room(stat)); });
        //_filters.add_getter<bool>("Clear Body", [](auto&& item) { return item.clear_body_flag(); });
        //_filters.add_getter<bool>("Invisible", [](auto&& item) { return item.invisible_flag(); });
        //_filters.add_getter<std::string>("Flags", [](auto&& item) { return format_binary(item.activation_flags()); });
        //_filters.add_getter<float>("OCB", [](auto&& item) { return static_cast<float>(item.ocb()); });
        // _filters.add_multi_getter<float>("Triggered By", [](auto&& item)
        //     {
        //         std::vector<float> results;
        //         for (auto trigger : item.triggers())
        //         {
        //             if (auto trigger_ptr = trigger.lock())
        //             {
        //                 results.push_back(static_cast<float>(trigger_ptr->number()));
        //             }
        //         }
        //         return results;
        //     });
    }
}
